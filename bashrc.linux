# mapping names to color escape sequences, taken from
# http://wiki.archlinux.org/index.php/Color_Bash_Prompt
txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset

# All non-printing characters are enclosed in \[ and \] to make sure long lines don't
# wrap all weird and on the same line.  See link immediately below
# http://tldp.org/HOWTO/Bash-Prompt-HOWTO/nonprintingchars.html
#export PS1="\[${txtred}\][\[${bldwht}\]\u@\h \[${bldblk}\]\w\[${txtred}\]]\[${txtrst}\]\$ "
export PS1='[\u@\h \w]\$ '

# Hack to work around the fact that gnome-terminal always sets TERM=xterm
if [[ "${TERM}" == "xterm" && "${COLORTERM}" == "gnome-terminal" ]]
then
	export TERM=xterm-256color
fi

# Set directory listing colors to those listed in ~/.dircolors
if [ -r ~/.dircolors ]
then
	alias ls='ls --color=auto'
	eval "$(dircolors ~/.dircolors)"
fi

# URxvt specific setting of font size.  See urxvt(1)
if [[ "${TERM}" =~ rxvt-unicode.* ]]
then
	function fnsz {
		printf '\e]710;xft:Monaco:pixelsize=%s\007' ${1}
	}
fi

if [[ "${TERM}" =~ xterm.* ]]
then
	function xterm-colorscheme {
		# The idea of this function is to take a .Xresouces or .Xdefaults file as input and
		# look through it for resources that would affect the way XTerm looks.  Then, when
		# we find them, emit the XTerm escape sequences to set those things dynamically.
		#
		# I'm sure I'm missing some things, but this seems to work relatively well in giving
		# me a way to dynamically change the XTerm colorscheme.
		local filename="${1}"
		declare -A defines

		# Escape sequences are documented in xterm source in `ctlseqs.ms' (or after
		# processing with nroff in `ctlseqs.txt').
		# Also available here: http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
		cat "${filename}" | while read line
		do
			if [[ "${line}" =~ ^#define ]]
			then
				read _ key value <<< "${line}"
				defines[${key}]=${value}
				continue
			elif [[ "${line}" =~ ^(XTerm|\*) ]]
			then
				additional=""
				read key value <<< "${line}"
				if   [[ "${key}" =~ foreground:$ ]]
				then
					op="10"
					# Additional is to set the highlight background color to the
					# current foreground color (i.e. reverse video)
					additional="printf \"\033]17;%s\007\" \"\${what}\""
				elif [[ "${key}" =~ background:$ ]]
				then
					op="11"
					# Additional is to set the highlight foreground color to the
					# current background color (i.e. reverse video)
					additional="printf \"\033]19;%s\007\" \"\${what}\""
				elif [[ "${key}" =~ color[0-9]+:$ ]]
				then
					color=$(echo "${key}" | sed -e 's/^.*color\([0-9][0-9]*\).*$/\1/')
					op="4;${color}"
				else
					continue
				fi

				if [[ -n "${defines[${value}]}" ]]
				then
					what="${defines[$value]}"
				else
					what="${value}"
				fi

				printf "\033]%s;%s\007" "${op}" "${what}"
				[[ -n "${additional}" ]] && eval ${additional}

			else
				continue
			fi
		done
	}
fi

# 2013-03-08: convert pse alias to function
function pse () {
	local args=("${@}")
	local selector=0

	for i in "${args[@]}"
	do
		if [[ "${i}" == "-t" || "${i}" == "-u" || "${i}" == "-p" ]]
		then
			selector=1
			break
		fi
	done

	[[ "${selector}" -eq 0 ]] && args=("${args[@]}" "-e")
	cmd=$(printf "ps -o user:12,pid,ppid,tid,nlwp,class,rtprio:3=RTP,ni,pri,bsdstart,vsz:9,rss:9,psr,pcpu,stat,wchan:25,tty,args %s" "${args[*]}")
	eval "${cmd}"
}
alias psef='pse --forest'
alias psel='pse -L'

# 2013-04-16: wrapper for nfsiostat to make it easier to read
# TODO: Remove the ability to pass flags that break parsing, i.e. `-h'.
function nfsiostat-formatted () {
	nfsiostat "$@" | awk '
	BEGIN {
		w_mnt    = 0;
		w_rdblks = 0;
		w_wrblks = 0;
		w_rddir  = 0;
		w_wrdir  = 0;
		w_rdsrv  = 0;
		w_wrsrv  = 0;
		w_ops    = 0;
		w_rops   = 0;
		w_wops   = 0;
		getline;
		getline;
	}

	$1 ~ /[-_A-Za-z0-9]+:/ {
		mnt    = $1;
		rdblks = $2;
		wrblks = $3;
		rddir  = $4;
		wrdir  = $5;
		rdsrv  = $6;
		wrsrv  = $7;
		ops    = $8;
		rops   = $9;
		wops   = $10;

		new_w_mnt = length(mnt);
		w_mnt = new_w_mnt > w_mnt ? new_w_mnt : w_mnt

		new_w_rdblks=length(rdblks);
		w_rdblks = new_w_rdblks > w_rdblks ? new_w_rdblks : w_rdblks

		new_w_wrblks=length(wrblks);
		w_wrblks = new_w_wrblks > w_wrblks ? new_w_wrblks : w_wrblks

		new_w_rddir=length(rddir);
		w_rddir = new_w_rddir > w_rddir ? new_w_rddir : w_rddir

		new_w_wrdir=length(wrdir);
		w_wrdir = new_w_wrdir > w_wrdir ? new_w_wrdir : w_wrdir

		new_w_rdsrv=length(rdsrv);
		w_rdsrv = new_w_rdsrv > w_rdsrv ? new_w_rdsrv : w_rdsrv

		new_w_wrsrv=length(wrsrv);
		w_wrsrv = new_w_wrsrv > w_wrsrv ? new_w_wrsrv : w_wrsrv

		new_w_ops=length(ops);
		w_ops = new_w_ops > w_ops ? new_w_ops : w_ops

		new_w_rops=length(rops);
		w_rops = new_w_rops > w_rops ? new_w_rops : w_rops

		new_w_wops=length(wops);
		w_wops = new_w_wops > w_wops ? new_w_wops : w_wops

		lines[i++] = $0;
	}

	$0 ~ /^$/ {
		for (j=0; j<i; j++) {
			split(lines[j], items, " ");
			printf("%-*s %*s %*s %*s %*s %*s %*s %*s %*s %*s\n",
				w_mnt,    items[1],
				w_rdblks, items[2],
				w_wrblks, items[3],
				w_rddir,  items[4],
				w_wrdir,  items[5],
				w_rdsrv,  items[6],
				w_wrsrv,  items[7],
				w_ops,    items[8],
				w_rops,   items[9],
				w_wops,   items[10]);
		}
		print;
		delete lines;
		i = 0;
	}'
}

# 2013-05-08: rpmenv function
function rpmenv () {
	cmd="${1}"
	name="${2}"

	if [[ ! "${cmd}" =~ ^enter$|^exit$ ]]
	then
		echo "rpmenv enter|exit [name]"
		return
	fi

	case "${cmd}" in
	enter)
		if [[ "${name}" =~ ^http:.*.src.rpm$|^ftp:.*.src.rpm$ ]]
		then
			url="${name}"
			name=$(echo "${name}" | sed -e 's/^.*\/\(.*\).src.rpm/\1/')
		fi

		name=$(basename ${name})
		d=${RPMENV_BASE}/${name}
		test \! -d ${d} && mkdir -p ${d}
		export _RPMENV_SAVED_PS1=${PS1}
		export _RPMENV_SAVED_PWD=${PWD}
		export PS1='[\u@\h [RPMENV:'${name}'] \w]\$ '
		cd ${d}
		alias rpmbuild="rpmbuild --define '_topdir ${d}'"
		alias rpm="rpm --define '_topdir ${d}'"

		if [[ -n "${url}" ]]
		then
			wget "${url}"
		fi
		;;
	exit)
		cd ${_RPMENV_SAVED_PWD}
		export PS1=${_RPMENV_SAVED_PS1}
		unset _RPMENV_SAVED_PWD
		unset _RPMENV_SAVED_PS1
		unalias rpm
		unalias rpmbuild
		;;
	esac
}

# 2014-03-21 formatted printing of /proc/mounts
function proc-mounts {
	fstype="${1}"

	if [[ -z ${fstype} ]]
	then
		fstype=".*"
	fi

	awk '
	{
		if ($3 ~ /'"${fstype}"'/) {
			field1_len = length($1);
			field2_len = length($2);
			field3_len = length($3);
			field4_len = length($4);
			field5_len = length($5);
			field6_len = length($6);

			field1_max = field1_len > field1_max ? field1_len : field1_max;
			field2_max = field2_len > field2_max ? field2_len : field2_max;
			field3_max = field3_len > field3_max ? field3_len : field3_max;
			field4_max = field4_len > field4_max ? field4_len : field4_max;
			field5_max = field5_len > field5_max ? field5_len : field5_max;
			field6_max = field6_len > field6_max ? field6_len : field6_max;
			lines[NR] = $0;
		}
	}

	END {
		for (i in lines) {
			split(lines[i], a);
			printf("%-*s  %-*s  %-*s  %*s  %*s  %*s\n",
				field1_max, a[1],
				field2_max, a[2],
				field3_max, a[3],
				field4_max, a[4],
				field5_max, a[5],
				field6_max, a[6]);
		}
	}' /proc/mounts | sort -k 3,2
}

# 2014-07-01 mapping of NFS mount points to sockets
function nfs-sockets {
	ss -iepn '( dport = :nfs )' \
	| awk '
		BEGIN {
			while ((getline < "/proc/mounts") > 0) {
				if ($3 == "nfs") {
					addr = gensub(/.*mountaddr=([^,]+).*/, "\\1", $4);
					if (mounts[addr])
						mounts[addr] = sprintf("%s %s", mounts[addr], $2);
					else
						mounts[addr] = $2
				}
			}
			getline
		}

		{
			state = $1;
			rcvq  = $2;
			sndq  = $3;
			local = $4;
			remot = $5;
			timer = $6;

			if (timer ~ /timer/) {
				ino = $7;
				sk  = $8;
			}
			else {
				timer = "";
				ino   = $6;
				sk    = $7;
			}

			getline;
			opts = $0;
			opts = gensub(/^[\t ]+/, "", opts);
			
			new_w_state = length(state);
			w_state = new_w_state > w_state ? new_w_state : w_state;

			new_w_rcvq = length(rcvq);
			w_rcvq = new_w_rcvq > w_rcvq ? new_w_rcvq : w_rcvq;

			new_w_sndq = length(sndq);
			w_sndq = new_w_sndq > w_sndq ? new_w_sndq : w_sndq;

			new_w_local = length(local);
			w_local = new_w_local > w_local ? new_w_local : w_local;

			new_w_remot = length(remot);
			w_remot = new_w_remot > w_remot ? new_w_remot : w_remot;

			new_w_timer = length(timer);
			w_timer = new_w_timer > w_timer ? new_w_timer : w_timer;

			new_w_ino = length(ino);
			w_ino = new_w_ino > w_ino ? new_w_ino : w_ino;

			new_w_sk = length(sk);
			w_sk = new_w_sk > w_sk ? new_w_sk : w_sk;

			new_w_opts = length(opts);
			w_opts = new_w_opts > w_opts ? new_w_opts : w_opts;

			lines[i++] = sprintf("%s|%s|%s|%s|%s|%s|%s|%s|%s", state, rcvq, sndq, local, remot, ino, sk, opts, timer);
		}

		END {
			for (j=0; j<i; j++) {
				split(lines[j], items, "|");
				split(items[5], remote_endpoint, ":");
				printf("%*s %*s %*s %*s %*s %-*s %*s %-*s %*s %s\n",
					w_state, items[1],
					w_rcvq,  items[2],
					w_sndq,  items[3],
					w_local, items[4],
					w_remot, items[5],
					w_ino,   items[6],
					w_sk,    items[7],
					w_opts,  items[8],
					w_timer, items[9],
					mounts[remote_endpoint[1]]);
			}
		}'
}
